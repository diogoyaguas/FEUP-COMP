options {
 
    LOOKAHEAD=1;
    MULTI = true;
    TRACK_TOKENS = true; 

}

PARSER_BEGIN(Program)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Program
{
    private static Program myProg;
    private static final String FILENAME = "test-file.txt";

    public static void main(String args[]) throws ParseException {

        //if(createInputStream() == false)
            //return;

        myProg = new Program(System.in);
        SimpleNode root = myProg.Program(); // devolve referencia para o nó da raiz da árvore
        root.dump("");
    }


	public static boolean createInputStream() {
        File file = new File(FILENAME);
                    
        FileInputStream stream;

        try {
		    stream = new FileInputStream(file);
		    myProg = new Program(stream);
        } catch (FileNotFoundException e) {
		    System.out.println("Error in stream constructor: ");
		    System.out.println("Usage: java Yal filePath [-r=<n>] [-o]");
		    e.printStackTrace();
		    return false;
	    }

        return true;

    } 
}

PARSER_END(Program)

SKIP: 
{
    " " 
| "\r"
| "\t"
| "\n"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}



TOKEN:
{
    <SEMI_COLON: ";" >
|   <COMMA: "," >
|   <PERIOD: "." >
|   <L_PARENTHESIS: "(" >
|   <R_PARENTHESIS: ")" >
|   <L_CBRACKET: "{" >
|   <R_CBRACKET: "}" >
|   <L_BRACKET: "[" >
|   <R_BRACKET: "]" >
|   <EXCLM_MARK: "!" >

|   <NEW: "new" >
|   <THIS: "this" >
|   <TRUE: "true" >
|   <FALSE: "false" >
|   <LENGTH: "length" >

|   <ADD_SUB: "+" | "-" >
|   <BINARY_OP: "&&" | "<" >
|   <ARITHM_OP: "*" | "/" >

|   <EQUAL: "=" >
|   <IF: "if" >
|   <ELSE: "else" >
|   <WHILE: "while" >

|   <INT: "int" >
|   <STRING: "String" >
|   <BOOLEAN: "boolean" >

|   <RETURN: "return" >
|   <PUBLIC: "public" >
|   <STATIC: "static" >
|   <VOID: "void" >
|   <MAIN: "main" >
|   <EXTENDS: "extends" >
|   <CLASS: "class" >
}

TOKEN:
{
    <ID: <LETTER> (<LETTER> | <DIGIT>)* > 
|   <DIGIT: (["0"-"9"]) >
|   <INTEGER: (<DIGIT>)+ >
|   <LETTER: (["a"-"z","A"-"Z", "_"])+ >
|   <OCTAL : 0["0"-"7"]+ >
|   <HEXA : 0["x""X"]["0"-"9""a"-"f""A"-"F"]+ >
|   <BINARY : 0["b""B"]["0"-"1"]+ >
}

SimpleNode Program() : {}  {
    (ClassDecl())*
}

void ClassDecl() : {} {

    <CLASS> <ID> <L_CBRACKET> <R_CBRACKET>

}

void VarDecl() : {} {
    
    Type() <ID> <SEMI_COLON>

}

void MainDecl() : {} {

    <PUBLIC> <STATIC> <VOID> <MAIN> <L_PARENTHESIS> <STRING> <L_BRACKET> <R_BRACKET> <ID> <R_PARENTHESIS> <L_CBRACKET> (VarDecl())* (Statement())* <R_CBRACKET>
}

void MethodDecl() : {} {

    <PUBLIC> (Type())* <ID> 
        <L_PARENTHESIS> 
            (Type() <ID> (<COMMA> Type() <ID>)*)? 
        <R_PARENTHESIS> 

    <L_CBRACKET> 
        (VarDecl())* (Statement())* <RETURN> Expression() <SEMI_COLON>
    <R_CBRACKET>
} 

void Type() : {} {

    <BOOLEAN> | <INT>(<L_BRACKET> <R_BRACKET>)?


}
void Statement() : {} {

    <L_CBRACKET> (Statement())* <R_CBRACKET> | <IF> <L_PARENTHESIS> Expression() <R_PARENTHESIS> Statement() <ELSE> Statement() | <WHILE> <L_PARENTHESIS> Expression() <R_PARENTHESIS> Statement() | Expression() <SEMI_COLON> | <ID> StatementAuxiliar()

}

void StatementAuxiliar() : {} {

    <EQUAL> Expression() <SEMI_COLON> | <L_BRACKET> Expression() <R_BRACKET> <EQUAL> Expression() <SEMI_COLON>
}

void IntegerLiteral() : {} {

    <INTEGER> | <OCTAL> | <HEXA> | <BINARY>      
}