options {
 
    LOOKAHEAD=1;
    MULTI = true;
    TRACK_TOKENS = true; 

}

PARSER_BEGIN(Program)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Program
{
    private static Program myProg;
    private static final String FILENAME = "test-file-inc.txt";

    public static void main(String args[]) throws ParseException {

        if(createInputStream() == false)
            return;

        //myProg = new Program(System.in);
        SimpleNode root = myProg.Program(); // devolve referencia para o nó da raiz da árvore
        root.dump("");
    }


	public static boolean createInputStream() {
        File file = new File(FILENAME);
                    
        FileInputStream stream;

        try {
		    stream = new FileInputStream(file);
		    myProg = new Program(stream);
        } catch (FileNotFoundException e) {
		    System.out.println("Error in stream constructor: ");
		    System.out.println("Usage: java Yal filePath [-r=<n>] [-o]");
		    e.printStackTrace();
		    return false;
	    }

        return true;

    } 
}

PARSER_END(Program)

JAVACODE
void skip_to(int token_kind){
    ParseException exception = generateParseException();
    System.out.println(exception.toString());

    Token t;
    do{
        t = getNextToken();
    }while(t.kind != token_kind);

}

SKIP: 
{
    " " 
| "\r"
| "\t"
| "\n"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}



TOKEN:
{
    <SEMI_COLON: ";" >
|   <COMMA: "," >
|   <PERIOD: "." >
|   <L_PARENTHESIS: "(" >
|   <R_PARENTHESIS: ")" >
|   <L_CBRACKET: "{" >
|   <R_CBRACKET: "}" >
|   <L_BRACKET: "[" >
|   <R_BRACKET: "]" >
|   <EXCLM_MARK: "!" >

|   <NEW: "new" >
|   <THIS: "this" >
|   <TRUE: "true" >
|   <FALSE: "false" >
|   <LENGTH: "length" >

|   <ADD: "+" >
|   <SUB: "-" >
|   <BINARY_OP: "&&" | "<" >
|   <MUL: "*" >
|   <DIV:  "/" >

|   <EQUAL: "=" >
|   <IF: "if" >
|   <ELSE: "else" >
|   <WHILE: "while" >

|   <INT: "int" >
|   <STRING: "String" >
|   <BOOLEAN: "boolean" >

|   <RETURN: "return" >
|   <PUBLIC: "public" >
|   <STATIC: "static" >
|   <VOID: "void" >
|   <MAIN: "main" >
|   <EXTENDS: "extends" >
|   <CLASS: "class" >
}

TOKEN:
{
    <ID: <LETTER> (<LETTER> | <DIGIT>)* > 
|   <#DIGIT: (["0"-"9"]) >
|   <INTEGER: ((<DIGIT>)+) >
|   <#LETTER: (["a"-"z","A"-"Z", "_"])+ >
|   <OCTAL : "0"(["0"-"7"])+ >
|   <HEXA : "0"["x","X"](["0"-"9","a"-"f","A"-"F"])+ >
|   <BINARY : "0"["b","B"](["0"-"1"])+ >
}

SimpleNode Program() : {}  {
    ClassDecl() <EOF> 
    {
        return jjtThis;
    }
}

void ClassDecl() #Class : {Token n;} {

    try{
    <CLASS> n = <ID> {jjtThis.name = n.image;} (ExtendClass())?
    <L_CBRACKET>
    }catch(ParseException e){
        System.out.println("CAUGHT CLASS INITIALIZATION DECLARATION");
        skip_to(L_CBRACKET);
    }
    try {
        (VarDecl())* (<PUBLIC> ( MainDecl() | MethodDecl()))* <R_CBRACKET>

    }catch(ParseException e){
        System.out.println("CAUGHT CLASS BLOCK DECLARATION");
        skip_to(R_CBRACKET);
    }

}

void ExtendClass() #Extends : {Token n;} {

    <EXTENDS> n=<ID> {jjtThis.name = n.image;}

}

void VarDecl() #Var: {Token n1; String s1;} {
    try{
        s1 = Type() {jjtThis.type = s1;}  n1=<ID> {jjtThis.name = n1.image;} <SEMI_COLON> 
    }catch(ParseException e){
        System.out.println("CAUGHT VAR DECLARATION");
        skip_to(SEMI_COLON);
    }

}

void MainDecl() #Main: {Token n2;} {
    try{
        <STATIC> <VOID> <MAIN> <L_PARENTHESIS> <STRING> <L_BRACKET> <R_BRACKET> n2=<ID>{jjtThis.name = n2.image;} <R_PARENTHESIS> <L_CBRACKET>
    }catch(ParseException e){
        System.out.println("CAUGHT MAIN INITIALIZATION DECLARATION");
        skip_to(L_CBRACKET);
    }
    try{
        (VarDecl())* (Statement())* <R_CBRACKET>
    }catch(ParseException e){
        System.out.println("CAUGHT MAIN BLOCK DECLARATION");
        skip_to(R_CBRACKET);
    }
}

void MethodDecl() #Method: {Token n3, n4; String s1;} {
    try{
        s1 = Type() {jjtThis.type = s1;} n3=<ID> {jjtThis.name = n3.image;}     
        <L_PARENTHESIS> MethodArgs() <R_PARENTHESIS> 
    }catch(ParseException e){
        System.out.println("CAUGHT METHOD DECLARATION");
        skip_to(R_PARENTHESIS);
    }
    try{
        <L_CBRACKET> 
            (VarDecl())* (Statement())* MethodReturn()
        <R_CBRACKET>
    }catch(ParseException e){
        System.out.println("CAUGHT METHOD BLOCK DECLARATION");
        skip_to(R_CBRACKET);
    }

}

void MethodArgs() #MethodArgs: {} {
    (Argument() (<COMMA> Argument())* )?
}

void Argument() #Argument: {Token t1; String s1;} {
    s1 = Type() {jjtThis.type = s1;} t1=<ID> {jjtThis.name = t1.image;}
}

void MethodReturn() #Return: {Token t1;} {
    t1=<RETURN> {jjtThis.value = t1.image;} Expression() <SEMI_COLON>
}

String Type() #void: {Token t1;} {

    t1=<BOOLEAN>{return t1.image;} | (t1=<INT>{return t1.image;}(<L_BRACKET> <R_BRACKET>)?)


}

void Statement() : {} {

        <L_CBRACKET> (Statement())* <R_CBRACKET> 
        | <IF> <L_PARENTHESIS> Expression() <R_PARENTHESIS> Statement() <ELSE> Statement() 
        |    try{ 
                <WHILE> <L_PARENTHESIS> Expression() <R_PARENTHESIS> Statement() 
                } catch(ParseException e) {
                    System.out.println("CAUGHT WHILE DECLARATION");
                    skip_to(R_PARENTHESIS);
                }
        | LOOKAHEAD(2) Expression() <SEMI_COLON> 
        | <ID> StatementAuxiliar()
    

}

void StatementAuxiliar() : {} {
    try{
        <EQUAL>  Expression() <SEMI_COLON> 
    }catch(ParseException e) {
        System.out.println("CAUGHT STATEMENT_AUXILIAR DECLARATION");
        skip_to(SEMI_COLON);
    }
    
   |
    
    try{ <L_BRACKET> Expression() <R_BRACKET> <EQUAL> Expression() <SEMI_COLON>
    }catch(ParseException e) {
        System.out.println("CAUGHT STATEMENT_AUXILIAR DECLARATION");
        skip_to(SEMI_COLON);
    }
}

void Expression() #void: {String s1;} {

    ( ExpressionTerminal()
   | <EXCLM_MARK> Expression()
   | <L_PARENTHESIS> Expression() <R_PARENTHESIS>
   | <NEW> New_Aux() ) Expression_Aux()

}

void ExpressionTerminal() #Term: {Token t1; String s1;} {

    s1 = IntegerLiteral() {jjtThis.node_value = s1;}
    | t1=<TRUE> {jjtThis.node_value = t1.image;}
    | t1=<FALSE> {jjtThis.node_value = t1.image;}
    | t1=<ID> {jjtThis.node_value = t1.image;}
    | t1=<THIS> {jjtThis.node_value = t1.image;}
}

void Expression_Aux() #void: {} {

    (
        LOOKAHEAD(2)(
        ((<MUL> | <DIV>) | <BINARY_OP> | (<ADD> | <SUB>)) Expression()
    | <L_BRACKET> Expression() <R_BRACKET>
    | <PERIOD> Period_Aux()
        ) 
        Expression_Aux()
    )?

}

void Period_Aux() : {} {

    <LENGTH>
    | <ID> <L_PARENTHESIS> (Expression() (<COMMA> Expression())*)? <R_PARENTHESIS>
}

void New_Aux() : {} {

    <INT> <L_BRACKET> Expression() <R_BRACKET>
    | <ID> <L_PARENTHESIS> <R_PARENTHESIS>
}

String IntegerLiteral() #void : {Token t1;} {

    ( t1=<OCTAL> {return t1.image;} 
    | t1=<INTEGER> {return t1.image;} 
    | t1=<HEXA> {return t1.image;} 
    | t1=<BINARY> {return t1.image;} )   
}
